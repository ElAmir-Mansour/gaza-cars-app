import 'dart:async';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:injectable/injectable.dart';
import '../../domain/entities/message_entity.dart';
import '../../domain/usecases/get_messages_usecase.dart';
import '../../domain/usecases/send_message_usecase.dart';
import 'message_event.dart';
import 'message_state.dart';

@injectable
class MessageBloc extends Bloc<MessageEvent, MessageState> {
  final GetMessagesUseCase getMessagesUseCase;
  final SendMessageUseCase sendMessageUseCase;
  StreamSubscription? _messagesSubscription;

  MessageBloc({
    required this.getMessagesUseCase,
    required this.sendMessageUseCase,
  }) : super(MessageInitial()) {
    on<LoadMessages>(_onLoadMessages);
    on<SendMessage>(_onSendMessage);
    on<_MessagesUpdated>(_onMessagesUpdated);
    on<_MessageErrorOccurred>(_onMessageErrorOccurred);
  }

  Future<void> _onLoadMessages(LoadMessages event, Emitter<MessageState> emit) async {
    emit(MessageLoading());
    await _messagesSubscription?.cancel();
    _messagesSubscription = getMessagesUseCase(event.chatId).listen(
      (messages) => add(_MessagesUpdated(messages)),
      onError: (error) => add(_MessageErrorOccurred(error.toString())),
    );
  }

  Future<void> _onSendMessage(SendMessage event, Emitter<MessageState> emit) async {
    final message = MessageEntity(
      id: '', // ID generated by Firestore
      senderId: event.senderId,
      text: event.text,
      timestamp: DateTime.now(),
      isRead: false,
    );
    
    // Optimistic update could be done here, but Stream will handle it.
    // We just fire and forget, or handle error.
    final result = await sendMessageUseCase(event.chatId, message);
    result.fold(
      (failure) => add(_MessageErrorOccurred(failure.message)),
      (_) {}, // Success handled by stream update
    );
  }

  void _onMessagesUpdated(_MessagesUpdated event, Emitter<MessageState> emit) {
    emit(MessageLoaded(event.messages));
  }

  void _onMessageErrorOccurred(_MessageErrorOccurred event, Emitter<MessageState> emit) {
    emit(MessageError(event.message));
  }

  @override
  Future<void> close() {
    _messagesSubscription?.cancel();
    return super.close();
  }
}

class _MessagesUpdated extends MessageEvent {
  final List<MessageEntity> messages;
  const _MessagesUpdated(this.messages);
  @override
  List<Object?> get props => [messages];
}

class _MessageErrorOccurred extends MessageEvent {
  final String message;
  const _MessageErrorOccurred(this.message);
  @override
  List<Object?> get props => [message];
}
